---
title: 3.1. 좋은 코드를 짜기 위한 원칙 & 자주 하는 실수들
categories:
  - 알고리즘 문제해결전략
  - 03. 코딩과 디버깅에 관하여
tags:
  - Algorithm
thumbnail: /gallery/computer.png
date: 2019-10-01 22:33:56
---



코딩 능력은 중요하다. 프로그래밍 대회에서 중요한 것은 빠르게 코딩을 하는 것보다 읽기 쉬운 코드를 작성하는 것이다. 그렇다면 어떻게 좋은 코드를 작성할 수 있을 지를 살펴보겠다.

## 1. 좋은 코드를 짜기 위한 원칙

#### 간결한 코드를 작성하기

첫번 째 원칙은 가장 **간결한 코드를 작성**하는 것이다. 코드가 짧을수록 오타나 단순한 버그가 생길 확률이 줄고 디버깅이 쉬워지기 때문이다.

일반적인 프로그래밍과 달리 프로그래밍 대회에서는 **전역변수를 많이 사용**한다. 코드가 짧고 적용 범위가 작기 때문에 가능한 일이다.

또는 **C/C++ 매크로를 사용**해서 간결한 코드를 작성한다. 정렬되지 않은 정수 배열에 중복 원소가 존재하는지 확인하는 함수가 있다고 하자.

```c++
bool hasDuplicate(const vector<int>& array) {
    for(int i = 0; i < array.size(); i++) {
        for(int j = 0; j < i; j++) {
            if (array[i] == array[j]) return true;
        }
    }
    return false;
}
```

위의 함수를 매크로를 사용해 다음과 같이 바꿀 수 있다.

```c++
#define FOR(i,n) for (int i = 0; i < (n); i++)
bool hasDuplicate(const vector<int>& array) {
    FOR(i, array.size())
        FOR(j, i)
           if (array[i] == array[j]) return true;
    return false;
```

위에서 정의해둔 매크로를 사용하는 것의 이점은 for 문의 조건식이나 증감식을 작성할 때 실수할 일이 없다는 것이다. 자바스크립트에서는 forEach 등을 사용하면 된다.

#### 적극적으로 코드 재사용하기

간결한 코드 작성을 위해서 코드를 모듈화하는 것이 좋다. 반복되는 코드를 함수나 클래스로 분리해 재사용한다.

**같은 코드가 세 번 이상 등장한다면 함수로 분리해 재사용** 하도록 한다.

#### 표준 라이브러리 공부하기

큐, 스택과 같은 자료구조, 혹은 정렬 같은 기초 알고리즘을 직접 작성하는 것은 대회에서는 시간낭비이다. **검증된 표준 라이브러리의 사용법을 반드시 잘 알아두자.**

#### 항상 같은 형태로 프로그램을 작성하기

이분법, 그래프 너비 우선 탐색과 같은 유명한 알고리즘부터 2차원 평면의 점을 표현하는 자료구조, 두 개 구간이 겹치는 지 확인하는 함수 등 여러 종류의 코드를 반복적으로 짜게 된다. 더 좋은 방법을 찾는 것도 좋지만 시간이 없을 때는 **한 번 검증된 코드를 작성하고 그것만을 꾸준히 사용**하는 것이 좋다. 도구가 아닌 문제에 집중하기 위해서이다.

#### 일관적이고 명료한 명명법 사용하기

int a, i, j, p, k, l 이런 식으로 선언하면 안 된다.

명확한 의미를 가진 변수명, 함수명을 사용해야 한다. 이름만 보고도 어떤 일을 하는 함수인지 알 수 있어 디버깅이 효율적이다.

#### 모든 자료를 정규화해서 저장하기

좋은 코드의 원칙으로 **같은 자료를 두 가지 형태로 저장하지 않는 것**이 있다. 예를 들면 유리수를 항상 약분해서 유일한 기약 분수 형태로 표현하는 것이 있다. 같은 자료가 두 개 이상의 표현을 가지게 되면 각각의 문자열 표현이 달라지고 해시 값이 달라지는 등의 문제가 있다.

정규화는 2차원 평면 상에서 (x, y)의 각도를 계산하는 문제에도 꼭 필요하다. 각도의 경우 -30도, 330도, 690도 등 여러가지로 표현할 수 있으므로 각도를 **표현하는 방법을 한 가지로 정의해둬야 한다**.

**정규화는 프로그램이 데이터를 입력받자마자 이루어져야 한다.**

#### 코드와 데이터를 분리하기

예를 들어 날짜를 다루는 프로그램을 작성할 때, 숫자 1이 들어오면 문자열 January 등으로 출력해야할 경우가 있다. 이 때 12달을 모두 if문 처리를 하는 것이 아니라 아래와 같은 자료구조를 사용한다.

```c++
const string monthName[] = {"January", "Feburary", "March", "April", ... };
```

열 두줄의 코드가 아닌, 간결해진 코드를 작성해서 실수를 줄일 수 있다. 달마다 날짜를 표현하고 싶다면 다음과 같은 구조를 사용한다.

```c++
int daysIn[12] = { 31, 28, 31, 31, 31, 30, 31, 31, 30, 31, 30, 31 };
```

체스판 문제 등에서 각 말이 움직일 수 있는 위치의 상대좌표를 배열에 저장해두면 좋다.

```c++
const int knightDx[8] = { 2, 2, -2, -2, 1, 1, -1, 1 };
const int knightDy[8] = { 1, -1, 1, -1, 2, 2, 2, -2 };
```



## 2. 자주 하는 실수

#### 산술 오버플로

프로그래밍 대회에서 가장 많이 하는 실수로, 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 산술 오버플로가 있다. 

#### 배열 범위 밖 원소에 접근

자바스크립트 등과 달리, C/C++은 배열의 원소에 접근할 때 해당 인덱스가 배열 범위 밖에 있는지 확인해주지 않는다. 버그를 찾기가 매우 어렵다.

```c++
int array[10], t;
```

위와 같은 C++ 코드에서 변수 array와 t는 연속된 메모리 상에 위치하게 된다. 이 때 array[10]에 잘못 접근하게 되면 에러 없이 t의 값이 손상된다. 이러한 버그는 에러를 내지 않아 찾기가 매우 어려워진다.

이러한 실수를 예방하는 가장 좋은 방법은 배열 크기를 정할 때 계산을 신중히 하는 것 뿐이다. 특히 배열의 index는 0으로 시작하지만,  표현하는 자료는 1부터 시작할 때 인덱스를 헷갈리기 쉬우니 조심해야 한다.

#### 일관되지 않은 범위 표현 방식 사용하기

열린구간과 닫힌구간을 정확하게 사용해야 한다. 프로그래밍 언어에서는 반 열린 구간을 사용한다. STL에서 제공하는 함수들의 범위 표현 방식은 대부분 begin <= elem < end 이다.

begin과 end가 같으면 공집합을 표현할 수 있다. 그러나 헷갈린다는 단점이 있다! 혼동하지 않으려면 프로그램 내에서 범위를 표현하는 방식을 통일할 필요가 있다.

#### Off-by-one 오류

Off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 많아서 틀리는 코드의 오류를 가리킨다. 답이 10개인데 11개가 나오는 등의 오류이다. 이런 오류는 보통 반복문에서 <=와 < 연산자를 혼동해서 일어난다.

이러한 오류를 방지하기 위해서는 최소 입력이 주어질 때 코드가 어떻게 동작할지를 되새기며 코딩하는 것이다.

#### 컴파일러가 잡아주지 못하는 상수 오타

위에서 사용한 상수 배열 등의 내용이 잘못된다면 컴파일러가 오류를 잡아줄 수 없으므로 디버깅이 더뎌진다는 문제가 있다. 출력할 문자열에 오타를 내는 것도 흔한 실수이다. C++의 경우 64비트 정수형의 수를 지정하지 않아 문제가 생기는 경우도 있다.

#### 스택 오버플로

재귀호출의 escape case가 없어서 콜 스택이 오버플로하는 경우가 종종 있다. while 문의 조건이 성립하지 않을 때도 이런 문제가 일어난다. C++의 경우 지역 변수로 선언한 배열이나 클래스 인스턴스가 스택 메모리를 사용하므로 조심해야 한다. STL 컨테이너를 사용하거나 전역 변수를 사용해 스택 메모리를 확보할 수 있다.

#### 다차원 배열의 인덱스 순서 바꿔 쓰기

동적 계획법을 위한 Memorization 패턴을 사용하다보면 다차원 배열을 사용할 일이 잦은데, 이런 경우에는 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋다. C++의 참조 변수를 사용해 문제를 해결할 수 있다.

#### 잘못된 비교 함수 작성

비교함수가 제대로 비교를 하지 못 하고 true, false를 옳지 않게 리턴하는 경우 해당 비교 함수를 사용하는 코드는 제대로 동작하지 않는다. 

#### 최소, 최대 예외 잘못 다루기

입력되는 데이터의 최소, 최대가 보장된다는 말이 없으면 따로 예외를 처리해줘야 한다.

#### 연산자 우선순위 잘못 쓰기

시프트 연산자나 비트 단위 연산자는 혼동하기 쉽다.

```c++
if (b & 1 == 0)
```

이는 비교 연산자 ==의 우선순위가 비트 단위 연산자 &보다 높기 때문에 아래와 같이 해석된다. 헷갈릴 때는 꼭 괄호를 사용하자.

```c++
if (b & (1 == 0)) // 원한 것과 다르게 이렇게 동작한다.
```

#### 너무 느린 입출력 방식 선택

C++의 경우, cin 또는 cout은 느리다. printf를 대신 사용하거나, 또는

`<cstdio>`의 표준 입출력 함수들과 동기화를 끄면 훨씬 빨라질 수 있다.

입력을 받기 전에 `cin.sync_with_stdio(false);`를 수행하면 된다.

#### 변수 초기화 문제

전역 변수를 사용할 때, 이전 입력에서 사용한 전역 변수가 초기화되지 않아 문제가 일어날 수 있다. 테스트케이스를 두 번씩 반복해서 실행해보거나, 변수를 적절히 초기화하면 예방할 수 있다.



